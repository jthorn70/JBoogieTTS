import random
import time
from twitchio.ext import commands
from better_profanity import profanity
import simpleaudio as sa
from pynput import keyboard
from requests.auth import HTTPBasicAuth
from audioplayer import AudioPlayer
import requests
import Bans
import Fact
import RemoveBlank

# cleaning up txt files and loading the censored words to block
RemoveBlank.remove_empty_lines('bans.txt')
RemoveBlank.remove_empty_lines('facts.txt')
profanity.load_censor_words_from_file('SwearWords.txt')

# list of mods for permissions
MODS = ['list mods here']

# vibes for the !vibecheck command
vibes = ['List your vibes here!']

# rigged vibes ez clap
boonVibes = ["rigged vibes here!"]

# Voice settings for each respective TTS
voice = 'jboogie'
JRvoice = 'chills'
modVoice = 'chills'


# Plays audio from a given path, with options to tweak based on voice parameter
def playAudio(path, voice):
    AudioPlayer(path).play(block=True)

    # if(voice == 'jboogie'):
    #     AudioPlayer(path).play(block=True)

    # else:
    #     AudioPlayer(path).play(block=True)


# generic on key press event.
def on_press(key):
    key
    # try:
    #     print('alphanumeric key {0} pressed'.format(
    #         key.char))
    # except AttributeError:
    #     print('special key {0} pressed'.format(
    #         key))


# generic on key released event, Used to stop all playing audio with a given keystroke, escape key default
def on_release(key):
    # print('{0} released'.format(
    #     key))
    if key == keyboard.Key.esc:
        sa.stop_all()
        return True


# keyboard listener for audio cancel hotkey
listener = keyboard.Listener(
    on_press=on_press,
    on_release=on_release)
listener.start()

# First step in the Uberduck API calls. This takes two params, text and voice, text is the sentence to be processed, voice is the voice used to sytnthesize the sentence. Returns the URL with the wav file for download


def postThatShit(text, voice):
    # data for message and voice
    stuff = {"speech": text, "voice": voice}

    # post request
    r = requests.post('https://api.uberduck.ai/speak', auth=('uberduck Key Here',
                      'uberduck Secret Here'), json=stuff)
    # print("THIS: ",r.request.headers)
    print(r.status_code)
    # print(r.text)

    # storing result as text and slicing the needed part of the URL
    uuid = r.text
    sliced = uuid[9:-2]
    # print("THIS: ", sliced)

    # combining URL
    myURL = "https://api.uberduck.ai/speak-status?uuid=" + sliced
    return myURL

# Second setp in the uberduck API calls. This takes one param, the URL generated by the first step in the API calls.


def getThatShit(myURL):
    p = requests.get(myURL, auth=('uberduck Key Here',
                     'uberduck Secret Here'))

    # print(p.text)
    # converting results to json. not sure if this is the best way or not
    results = p.json()
    # getting path of wav file (not working from cli but works if you copy paste URL)
    path = results['path']

    # print("RESULTS: ",results['finished_at'])

    if str(results['path']) == "null":
        print("Not done. try agin in 1")
        # time.sleep(1)
        getThatShit(myURL)
    else:
        # print("Path: ",results['path'])
        # print("URL: ",myURL)
        # print("THIS IS THE PATH IN GET: ",path)

        return path

# Downloads the wav file from the path returned by the uberduck get request (for the main trick TTS)


def downloadWav(path):
    print("Starting Download")
    r = requests.get(path)
    DLPath = 'Path to trick wav download'
    #print("DLPATH: ", DLPath)
    with open(str(DLPath), 'wb') as f:
        f.write(r.content)

# Downloads the wav file for the latest generated sentence from the markov chain bot


def downloadJRWav(path):
    print("Starting Download")
    r = requests.get(path)
    DLPath = 'Path to JR wav download'
    #print("DLPATH: ", DLPath)
    with open(str(DLPath), 'wb') as f:
        f.write(r.content)

# Downloads the sneaky mod TTS wav


def downloadModWav(path):
    print("Starting Download")
    r = requests.get(path)
    DLPath = 'Path to MOD wav download'
    print("DLPATH: ", DLPath)
    with open(str(DLPath), 'wb') as f:
        f.write(r.content)


# This is the start of the actual twitch bot
class Bot(commands.Bot):

    def __init__(self):
        # Initialise our Bot with our access token, prefix and a list of channels to join on boot...
        super().__init__(token='Access Token Goes Here',
                         prefix='!', initial_channels=['Your Channel Name Here'])

    async def event_ready(self):
        # We are logged in and ready to chat and use commands...
        print(f'Logged in as | {self.nick}')

    async def event_message(self, message):
        print(message.author.name, ": ", message.content)
        if (message.author.name == "boonjunior"):
            g = open("junior.txt", "w")
            g.write(message.content.lower())
            g.close()

        await self.handle_commands(message)

    # Command for trick request
    @commands.command(name='trick')
    async def trick(self, ctx: commands.Context):
        trickRequest = str(ctx.message.content)[6:]
        insults = ["Your Insults Go Here!"]
        suffix = ["Your Suffixes Go Here!"]
        randInsult = random.choice(insults)
        randSuffix = random.choice(suffix)
        message = randInsult + ctx.author.name + \
            ", requested" + trickRequest + ". " + randSuffix
        currentTrick = "Current Trick: " + trickRequest + \
            ", Requested by " + ctx.author.name
        if (ctx.author.name.lower() in Bans.banList):
            await ctx.channel.send("ACCESS DENIED")
            message = ""

        if (ctx.author.name.lower not in Bans.banList):

            if (len(ctx.message.content) > 200):
                await ctx.channel.send("Message too long jabroni")
                message = "Message too long jabroni."
                currentTrick = ""

            if (profanity.contains_profanity(ctx.message.content)):
                censored = profanity.censor(trickRequest, 'za')
                message = randInsult + ctx.author.name + \
                    ", requested" + censored + ". " + randSuffix
                # await ctx.channel.send(ctx.author.name + ", thank you for your request")
                # print(ctx)
                j = open("transcript.txt", "w")
                j.write(message)
                j.close()
            else:
                myURL = postThatShit(message, voice.strip())
                print('URL: ', myURL)
                time.sleep(1)
                if "https" not in str(getThatShit(myURL)):
                    time.sleep(5)
                    newURL = (getThatShit(myURL))
                    downloadWav(newURL)
                downloadWav(getThatShit(myURL))
                playAudio(
                    "Path to trick wav download", voice)
                # wave_obj = sa.WaveObject.from_wave_file("Path to trick wav download")
                # play_obj = wave_obj.play()
                # play_obj.wait_done()
                # playsound('Path to trick wav download')

                # print(ctx)
                f = open("trick.txt", "w")
                f.write(currentTrick)
                f.close()

                j = open("transcript.txt", "w")
                j.write(message)
                j.close()

                # await ctx.send(f'{message}')

                await ctx.channel.send(ctx.author.name + ", thank you for your request")
        else:
            await ctx.channel.send(ctx.author.name + ": ACCESS DENIED")

    # command for getting your size in chat
    @commands.command(name='size')
    async def size(self, ctx: commands.Context):
        longth = random.randint(1, 12)
        thickness = random.randint(1, 5)
        curve = random.randint(0, 30)

        if (longth == 0 and thickness == 0):
            await ctx.channel.send(ctx.author.name + " is cockless LUL")
        elif(longth < 5):
            await ctx.channel.send(ctx.author.name + " is about " + str(thickness) + " inches thicc, and " + str(longth) + " inches wide. With a curve of " + str(curve) + " degrees.")
        elif(longth == thickness):
            await ctx.channel.send(ctx.author.name + " is about " + str(thickness) + " inches thicc, and " + str(longth) + " inches wide.With a curve of " + str(curve) + " degrees." + " SQUARE COCK GANG ")
        else:
            await ctx.channel.send(ctx.author.name + " is about " + str(thickness) + " inches thicc, and " + str(longth) + " inches wide.With a curve of " + str(curve) + " degrees.")

    # command for getting your/someones vibe in chat
    @commands.command(name='vibecheck')
    async def newvibe(self, ctx: commands.Context):
        randVibe = random.choice(vibes)
        randBoon = random.choice(boonVibes)
        vibeTarget = str(ctx.message.content)[10:]

        if (vibeTarget == ""):
            vibeTarget = ctx.author.name

        if (ctx.author.name == "jboondock" or ctx.author.name == "jbooogie"):
            await ctx.channel.send(vibeTarget + " has " + randBoon)
        else:
            await ctx.channel.send(vibeTarget + " has " + randVibe)

    # command for loading facts from txt file
    @commands.command(name='loadfacts')
    async def loadfacts(self, ctx: commands.Context):
        if(ctx.author.name in MODS):
            Fact.loadFacts()
            await ctx.channel.send("Facts Loaded!")

    # command for adding fact i.e !addfact Jboogie is a stinky man...
    @commands.command(name='addfact')
    async def addfact(self, ctx: commands.Context):
        fact = str(ctx.message.content)[9:]
        if(ctx.author.name in MODS):
            Fact.addFact(fact)
        # await ctx.channel.send(fact+" added to list")

    # command for removing a fact from the list, must match exact, this could be handled better
    @commands.command(name='remfact')
    async def remfact(self, ctx: commands.Context):
        fact = str(ctx.message.content)[9:]
        if(ctx.author.name in MODS):
            Fact.removeFact(fact)
            Fact.saveFacts()
        # await ctx.channel.send(fact+" removed from list")

    # command for loading list of ppl blacklisted from using the TTS bot
    @commands.command(name='loadbans')
    async def loadbans(self, ctx: commands.Context):
        if(ctx.author.name in MODS):
            Bans.loadBans()
            await ctx.channel.send("Bans Loaded!")

    # command for adding someone to the blacklist for the TTS bot
    @commands.command(name='addban')
    async def addban(self, ctx: commands.Context):
        name = str(ctx.message.content)[8:]
        if(ctx.author.name in MODS):
            Bans.addBan(name)
            Bans.saveBans()
        # await ctx.channel.send(name+" added to list")

    # command for removing someone from the blacklist for the TTS bot
    @commands.command(name='remban')
    async def remban(self, ctx: commands.Context):
        name = str(ctx.message.content)[8:]
        if(ctx.author.name.lower() in MODS):
            Bans.removeBan(name)
            Bans.saveBans()
        # await ctx.channel.send(name+" removed from list")

    # command for listing the users blacklisted from the TTS bot
    @commands.command(name='bans')
    async def bans(self, ctx: commands.Context):
        if(ctx.author.name in MODS):
            await ctx.channel.send(Bans.banList)

    # command for sending a random fact from the fact list in chat
    @commands.command(name='randfact')
    async def randfact(self, ctx: commands.Context):
        randFact = random.choice(Fact.facts)
        await ctx.channel.send(randFact)

    # command for info about the bot
    @commands.command(name='info')
    async def TTS(self, ctx: commands.Context):
        await ctx.channel.send("Created by JBoondock, Github repository: https://github.com/jthorn70/JBoogieTTS, Donate: https://paypal.me/jboondock?country.x=US&locale.x=en_US")

    # command for speaking latest markov chain bot generation
    @commands.command(name='bb')
    async def brainblast(self, ctx: commands.Context):
        global JRvoice
        if(ctx.author.name in MODS):
            with open('junior.txt') as myFile:
                for line in myFile:
                    message = line
            # message = ctx.message.content

            if (profanity.contains_profanity(ctx.message.content)):
                censored = profanity.censor(message, 'za')
                myURL = postThatShit(censored, JRvoice.strip())
                print('JR URL: ', myURL)
                time.sleep(1)
                if "https" not in str(getThatShit(myURL)):
                    time.sleep(3)
                    newURL = (getThatShit(myURL))
                    downloadJRWav(newURL)
                downloadJRWav(getThatShit(myURL))
                playAudio(
                    "Path to JR wav download", JRvoice)
            else:
                myURL = postThatShit(message, JRvoice.strip())
                print('JR URL: ', myURL)
                time.sleep(5)
                if "https" not in str(getThatShit(myURL)):
                    time.sleep(5)
                    newURL = (getThatShit(myURL))
                    downloadJRWav(newURL)
                downloadJRWav(getThatShit(myURL))
                playAudio(
                    "Path to JR wav download", JRvoice)

    # command to change the TTS voice, only available to mods and streamer
    @commands.command(name='voice')
    async def voice(self, ctx: commands.Context):
        global voice

        if(ctx.author.name in MODS):
            if (str(ctx.message.content)[9:] == ""):
                await ctx.channel.send("Main voice is set to: " + voice)
            else:
                voice = str(ctx.message.content)[9:]
                await ctx.channel.send("new voice for TTS is: " + voice)
            # print(voice)

        if (voice == ""):
            await ctx.channel.send("Main voice is set to: " + voice)

    # command to change the voice of the markov chain generation TTS
    @commands.command(name='jrvoice')
    async def jrvoice(self, ctx: commands.Context):
        global JRvoice
        if(ctx.author.name in MODS):
            if (str(ctx.message.content)[8:] == ""):
                await ctx.channel.send("JR's voice is set to: " + JRvoice)
            else:
                JRvoice = str(ctx.message.content)[8:]
                await ctx.channel.send("new voice for JR is: " + JRvoice)
                # print(JRvoice)

        if (voice == ""):
            print("JR's voice is set to: " + JRvoice)

    # command to change the voice of the sneaky mod TTS
    @commands.command(name='modvoice')
    async def modvoice(self, ctx: commands.Context):
        global modVoice

        if(ctx.author.name in MODS):
            if(str(ctx.message.content)[9:] == ""):
                await ctx.channel.send("Mod voice is set to: " + modVoice)
            else:
                modVoice = str(ctx.message.content)[9:]
                await ctx.channel.send("new voice for mods is: " + modVoice)

        if(voice == ""):
            print("mod voice is set to: " + modVoice)

    # command for a simple TTS for mods (sneaky)
    @commands.command(name='speak')
    async def speak(self, ctx: commands.Context):
        global modVoice
        if(ctx.author.name in MODS):
            message = str(ctx.message.content)[6:]
            censored = profanity.censor(message, 'za')
            myURL = postThatShit(censored, modVoice.strip())
            print('MOD URL: ', myURL)
            time.sleep(1)
            if "https" not in str(getThatShit(myURL)):
                time.sleep(5)
                newURL = (getThatShit(myURL))
                downloadModWav(newURL)
            downloadModWav(getThatShit(myURL))
            playAudio(
                "Path to MOD wav download", modVoice)


bot = Bot()
bot.run()
